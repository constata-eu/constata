"Contains the verifiable HTML for this certified entry."
type EntryHtmlExport {
  "The numerical identifier of the entry."
  id: Int!
  "The entry itself."
  entry: Entry!
  "The verifiable HTML proof."
  verifiableHtml: String!
}

"Represents a batch generation and certification of diplomas, proofs of attendance, and badges from a template. Can be started from a CSV file using CreateIssuanceFromCsv, or from json directly using CreateIssuanceFromJson."
type Issuance {
  "Unique identifier for the issuance."
  id: Int!
  "Identifier of the template linked to this issuance."
  templateId: Int!
  "Name of the template linked to this issuance."
  templateName: String!
  "The kind of template, which can be 'DIPLOMA', 'ATTENDANCE', or 'BADGE'."
  templateKind: TemplateKind!
  "The state of the issuance, which can be 'received': The recipients data has been received, and we're in the process of generating each recipients document; 'created': Individual entries have been generated from the selected template, using each recipient's data. At this point you can still add more recipients which will rewind the state to 'received'; 'signed': You have signed the entries, no further entries can be added. Documents will be certified and notified within 2 hours; 'completed': All entries have been certified and notified; 'failed': An error ocurred in the creation process, and the whole issuance has been aborted. Look at the errors field for more details."
  state: String!
  "The name of the issuance."
  name: String!
  "The date on which this issuance was created."
  createdAt: DateTime!
  "Errors that happened in the process of the issuance, if any. When an error occurs, the whole issuance is halted and no documents are certified."
  errors: String
  "Amount of tokens that the user must buy to certify this issuance."
  tokensNeeded: Int
  "Entry count for this issuance. All entries can be fetch separately with an Entries query, filtering by issuance id."
  entriesCount: Int!
  "Stats: How many recipients viewed the admin link that was sent to them."
  adminVisitedCount: Int!
  "Stats: How many visits did the published entries in this Issuance get, collectively."
  publicVisitCount: Int!
}

"This resource is used by Constata's frontend when you attempt to verify your email address following a link we send to your email."
type EmailAddressVerification {
  "Unique id of the email address that was verified"
  id: Int!
}

"This object has a file that proves the user identity"
input KycRequestEvidenceInput {
  "name of the file used as evidence for this kyc request" filename: String!
  "the file itself" payload: String!
}

"This object allows us to submit a kyc request to be considered by a constata admin"
input KycRequestInput {
  "email to be registered by the person" email: String!
  "boolean pointing out whether the email should be registered as private or could be public" keepPrivate: Boolean!
  "Your first names" name: String!
  "Your last names" lastName: String!
  "Government or otherwise officially issued ID number" idNumber: String
  "Type of the officially issued id. Ej: DNI" idType: String
  "Date of birth" birthdate: DateTime
  "Country of birth" nationality: String
  "Country you currently live in." country: String
  "Your role, title or position in your company, if any." jobTitle: String
  "Name of the company" legalEntityName: String
  "Country where the company is based on, or where it has its HQ." legalEntityCountry: String
  "Company registration number in the required public registries, if any." legalEntityRegistration: String
  "Company tax identification number" legalEntityTaxId: String
  "Your company LinkedIn page, if any." legalEntityLinkedinId: String
  "The files attached as proof for the details provided." evidence: [KycRequestEvidenceInput!]!
}

"The personal and company details you sent Constata for verification and to include in all your signed certificates. Keep in mind all fields are optional, this data is protected by data protection laws such as GDPR. https://api.constata.eu/terms_acceptance/show/#privacy_policies "
type KycEndorsementManifest {
  "Your first names"
  name: String
  "Your last names"
  lastName: String
  "Government or otherwise officially issued ID number"
  idNumber: String
  "Type of the officially issued id. Ej: DNI"
  idType: String
  "Date of birth"
  birthdate: DateTime
  "Country of birth"
  nationality: String
  "Country you currently live in."
  country: String
  "Your role, title or position in your company, if any."
  jobTitle: String
  "Name of the company"
  legalEntityName: String
  "Country where the company is based on, or where it has its HQ."
  legalEntityCountry: String
  "Company registration number in the required public registries, if any."
  legalEntityRegistration: String
  "Company tax identification number"
  legalEntityTaxId: String
  "Date of last update to this data."
  updatedAt: DateTime!
}

"The public key of a Person is used to sign certificates created through Issuances and Attestations. It's also used to authenticate to this API."
type Pubkey {
  "Unique ID of the pubkey, corresponds to a mainnet bitcoin address."
  id: String!
  personId: Int!
  orgId: Int!
}

input IssuanceFilter {
  ids: [Int!]
  idEq: Int
  templateIdEq: Int
  stateEq: String
  nameLike: String
}

scalar Addr

"A list of WebCallbacks we've sent you or are working on sending you, to help you debug your web callbacks integration."
type WebCallback {
  "Unique identifier for this Entry, across all Issuances."
  id: Int!
  "The kind of callback, relates to the event that triggered this callback, for example, an attestation being done."
  kind: WebCallbackKind!
  "The related resource ID, has a different meaning depending on the web callback kind. If its about an attestation, the it's the attestation's id."
  resourceId: Int!
  "The state of this callback. Pending, Done or Failed. Callbacks are retried 10 times with exponential backoff. The first attempt is done immediately, the second one 5 minutes later, then at 10 minutes, 20, and so on. All attempts are WebCallbackAttempt."
  state: WebCallbackState!
  "The most recent attempt, if any."
  lastAttemptId: Int
  "The date on which this web callback was scheduled. It's around to the time of the event that triggered it, but may be a few seconds later."
  createdAt: DateTime!
  "Date in which this WebCallback will be attempted. When the WebCallback is Done or Failed it will remain set to the date of the last attempt."
  nextAttemptOn: DateTime!
  "The body of the request we will be sending via POST to your web_callbacks_endpoint"
  requestBody: String!
}

enum WebCallbackState {
  PENDING
  DONE
  FAILED
}

enum TemplateKind {
  DIPLOMA
  ATTENDANCE
  BADGE
}

enum WebCallbackResultCode {
  OK
  NETWORK_ERROR
  NO_CALLBACKS_URL_FOR_ORG
  NON_SUCCESS_RESPONSE
}

"This is your organization's account information and stats."
type AccountState {
  "Unique ID of your organization assigned by us."
  id: Int!
  "Tokens your organization needs to buy in order to certify all parked documents created through Issuances, Attestations or any other means."
  missing: Int!
  "You have this many tokens in your balance."
  tokenBalance: Int!
  "The special price you'll pay for each token when you buy them."
  pricePerToken: Int!
  "Constata will give you a monthly bonus of this many tokens, as a gift. When you submit an Issuance, Attestation or perform any other token consuming action, we'll credit these tokens as a gift instead of consuming your token balance."
  maxMonthlyGift: Int!
  "This number lowers every time Constata gives you a token from your max_monthly_gift"
  monthlyGiftRemainder: Int!
  "You have this many documents parked, that is, they won't be certified, until you take the requested action which may be buying the tokens needed to certify them, or accept changes to our terms and conditions."
  parkedCount: Int!
  "These are all the invoices you created for purchasing tokens and are still waiting for payment."
  invoices: [Invoice!]!
  "When this url is available, you should visit it on your browser to review and accept our terms and conditions. You can send it to whoever is in charge of accepting the terms in your organization."
  pendingTycUrl: String
  "Whenever you are missing tokens, you can visit this url in your browser and it will present you with payment options to buy the tokens you need. No login required, so you can send it to anyone in your organization in charge of payments."
  pendingInvoiceLinkUrl: String
  "This should be an address on your own website such as 'https://yoursite.com/web_callbacks_from_constata' where we can notify you about done attestations, issuances, or pending token purchases."
  webCallbacksUrl: String
}

"Your email account, as verified by Constata's email robot."
type EmailEndorsementManifest {
  address: String!
  "Whether you told us to use this email as part of your public endorsements or not."
  keepPrivate: Boolean!
}

"This object show an email address information"
type EmailAddress {
  "number identifying this email address"
  id: Int!
  "Id of the Person ownining this address"
  personId: Int!
  "The actual email address."
  address: String!
  "Date when the email was verified, if verified."
  verifiedAt: DateTime
  "Whether constata should also make this address part of the person's public signature information"
  keepPrivate: Boolean!
}

"A CreateIssuanceFromJsonInput configures a new Issuance, with optional initial entries, where more new entries may be added later. Once all desired entries have been added, the issuance may be signed and will be certified and optionally distributed by Constata. If you want to create an Issuance all at once from a single CSV file we suggest you use CreateIssuanceFromCsvInput."
input CreateIssuanceFromJsonInput {
  "An array of JSON objects corresponding to each recipient for whom you want to create a diploma, certificate of attendance or badge" entries: [EntryParams!]!
  "The name of the Issuance to be created." name: String!
  "The ID of an existing template to use, if any. See the allTemplates query." templateId: Int
  "The kind of template to be created if no template_id is given." newKind: TemplateKind
  "The name of the new template to be created, if no template_id is given." newName: String
  "The text to be used as the logo for the new template, if no template_id is given." newLogoText: String
  "The base64 encoded image to be used as the logo for the new template, if no template_id is given. If you leave it empty your new_logo_text will be displayed." newLogoImage: Bytes
}

"Used to publish/unpubish an attestation, so that anyone can see it hosted in Constata's website"
input AttestationSetPublishedInput {
  attestationId: Int!
  publish: Boolean!
}

"SigningIteratorInput Object"
input SigningIteratorInput {
  "ID of the issuance to which this entry belongs." issuanceId: Int!
  "Number that identifies this entry." entryId: Int
  "Signature applied to the referenced entry." signature: String
}

"This object show the id of the newly created person in reply to a signup. Remember signup can only be done through the website as some spam filtering checks are performed there."
type Signup {
  "number identifying the person who signed up"
  id: Int!
}

input EntryFilter {
  ids: [Int!]
  idEq: Int
  issuanceIdEq: Int
  stateEq: String
  documentIdEq: String
  paramsLike: String
}

input KycRequestFilter {
  ids: [Int!]
  idEq: Int
  stateEq: String
}

"This is the best way to compose an Issuance incrementally. You can add new entries at any time before signing the Issuance. Entries will be validated as they are recevied, and then will be 'created' by our workers. In the unlikely case an entry passes validation and is received, but then an error when our worker tries to create it, the request will be marked as failed, as well as all other entries. "
input AppendEntriesToIssuanceInput {
  "The ID of the Issuance to which the entries are to be appended." issuanceId: Int!
  "An array of JSON objects corresponding to each recipient for whom you want to create a diploma, certificate of attendance or badge. ie: '[{\"name\":\"Alice\",\"motive\":\"Cream of the crop\"},{\"name\":\"Bob\",\"motive\":\"Accredited Expert\"}]'" entries: [EntryParams!]!
}

input WebCallbackFilter {
  ids: [Int!]
  idEq: Int
  stateEq: WebCallbackState
  resourceIdEq: Int
  kindEq: WebCallbackKind
}

"Represents an HTML preview of the contents of an entry."
type PreviewEntry {
  "The numerical identifier of the entry."
  id: Int!
  "The HTML formatted contents of the entry."
  html: String!
}

scalar MsgSig

type TemplateSchemaField {
  name: String!
  optional: Boolean!
  common: Boolean!
  label: String
  labelEs: String
  help: String
  sample: String
}

"This object represents the link received by a user when requested to choose a payment method to buy tokens."
type InvoiceLink {
  "Number identifying an invoice link."
  id: Int!
  "Minimum suggested amount of tokens for the user to buy, taking into account missing tokens."
  minimumSuggested: Int!
  "Price per token that the user is going to pay."
  pricePerToken: Int!
  "URL of the invoice created with this invoice link, if any."
  invoiceUrl: String
}

type ListMetadata {
  count: Int!
}

"An Attestation over several documents"
type Attestation {
  id: Int!
  personId: Int!
  orgId: Int!
  markers: String!
  openUntil: DateTime
  state: String!
  parkingReason: String
  doneDocuments: Int!
  parkedDocuments: Int!
  processingDocuments: Int!
  totalDocuments: Int!
  tokensCost: Float!
  tokensPaid: Float!
  tokensOwed: Float!
  buyTokensUrl: String
  acceptTycUrl: String
  lastDocDate: DateTime
  emailAdminAccessUrlTo: [String!]!
  adminAccessUrl: String
  publicCertificateUrl: String
  createdAt: DateTime!
}

"Contains the verifiable HTML for this certified entry."
type UnsignedEntryPayload {
  "The numerical identifier of the entry."
  id: Int!
  "The entry itself."
  entry: Entry!
  "The base64 encoded contents of this entry. It's always a zip file."
  bytes: Bytes!
}

scalar EntryParams

"This input object allows changing the public_certificate_is_active flag, to enable and disable sharing publicly."
input DownloadProofLinkInput {
  "Send 'publish' to enable, or 'unpublish' to disable. Any other value will be understood as 'unpublish'." action: String!
}

"This resource is used by Constata's admin front-end to show options for viewing, downolading or sharing a certificate on social networks. NOTICE: You should probably never use this resource yourself, use the Attestation and Issuance resources instead. If you insist on using it, keep in mind this endpoint does not authenticate using the 'Authentication' header, you should send an Auth-Token header with the special token generated for administrative access."
type DownloadProofLink {
  "Unique ID for this link."
  id: Int!
  "Expiration date, this admin link will not be valid after this date and time."
  validUntil: DateTime
  "A verifiable certificate may contain several documents. This many are pending to be certified."
  pendingDocCount: Int!
  "Creation date of the last document in this verifiable certificate."
  lastDocDate: DateTime
  "Public URL that displays this certificate, if sharing is active."
  publicCertificateUrl: String!
  "Whether this certificate's sharing is active. If so, the public_certificate_url can be shared on social media and viewed by anyone."
  publicCertificateIsActive: Boolean!
  "The text to display in the front-end for the 'share on social media' call to action."
  shareOnSocialNetworksCallToAction: String!
  documentFundedAt: DateTime
  entryTitle: String
  legalEntityLinkedinId: String
}

"A CreateIssuanceFromCsvInput configures a new Issuance, with at least one recipient, where more new entries may be added later. Once all desired entries have been added, the issuance may be signed and will be certified and optionally distributed by Constata. If you want to create an Issuance all at once from a single CSV file we suggest you use the Wizard endpoint."
input CreateIssuanceFromCsvInput {
  "The CSV string to be used for creating the issuance" csv: String!
  "The name of the Issuance to be created." name: String!
  "The ID of an existing template to use, if any. See the Templates resource." templateId: Int
  "The kind of template to be created if no template_id is given." newKind: TemplateKind
  "The name of the new template to be created, if no template_id is given." newName: String
  "The text to be used as the logo for the new template, if no template_id is given." newLogoText: String
  "The base64 encoded image to be used as the logo for the new template, if no template_id is given. If you leave it empty your new_logo_text will be displayed." newLogoImage: Bytes
}

"A template that serves as a foundation for creating each Issuance Entry."
type Template {
  "An identifier for this template"
  id: Int!
  "The name of this template"
  name: String!
  "The type of issuance that can be created from this template. Possible values are 'Diploma', 'Attendance', or 'Badge'."
  kind: TemplateKind!
  "The date when this template was created"
  createdAt: DateTime!
  "The schema used to build the issuance entry"
  schema: [TemplateSchemaField!]!
  "A personalized message that the user can add to the email sent to the student when the entry is certified"
  customMessage: String
  "Stats: How many recipients viewed the admin link that was sent to them."
  adminVisitedCount: Int!
  "Entry count for all issuances that used this template."
  entriesCount: Int!
  "Stats: How many visits did the published entries in this Template get, collectively."
  publicVisitCount: Int!
  "Whether this template was archived by the user."
  archived: Boolean!
}

"""
  Combined date and time (with time zone) in [RFC 3339][0] format.

  Represents a description of an exact instant on the time-line (such as the
  instant that a user account was created).

  [`DateTime` scalar][1] compliant.

  See also [`chrono::DateTime`][2] for details.

  [0]: https://datatracker.ietf.org/doc/html/rfc3339#section-5
  [1]: https://graphql-scalars.dev/docs/scalars/date-time
  [2]: https://docs.rs/chrono/latest/chrono/struct.DateTime.html
"""
scalar DateTime

"You can get an attestation as a verifiable HTML, embedding all documents and verifiable in any default browser."
type AttestationHtmlExport {
  id: Int!
  attestation: Attestation!
  "The verifiable HTML proof."
  verifiableHtml: String!
}

"A Person may have many endorsements from Constata, such as their identity, owning an email account, or being the manager of a website. This manifest gathers all those endorsements. You can only query your own manifest for now."
type EndorsementManifest {
  "You'll always get number 1."
  id: Int!
  "the final text to be used as the user endorsements, if any"
  text: String
  "websites registered by the user, if any"
  websites: [String!]!
  "data from the user's kyc endorsement, if any"
  kyc: KycEndorsementManifest
  "email registered by the user, if any"
  email: EmailEndorsementManifest
  "boolean pointing out whether the an email is going to be send to the student when created an issuance"
  canSendEmail: Boolean!
}

enum WebCallbackKind {
  ATTESTATION_DONE
}

scalar Bytes

"This object retrieves a certificate in verifiable HTML format authenticating with a special token, generated by our backend. This links can be sent to anyone and they will download the verifiable HTML. NOTICE If you need to download the verifiable HTML for any certificate authenticating to our API with your credentials, use the Issuances or Attestations endpoints instead."
type Proof {
  "Id of the certification "
  id: Int!
  "Certificate HTML contents as text"
  html: String!
}

"This object is used by our frontend when a customer receives a link to create an invoice to purchase tokens."
input InvoiceLinkInput {
  "The payment method to use for this invoice ('Bitcoin' or 'Stripe')." paymentMethod: String!
  "The number of tokens to purchase with this invoice." tokens: Int!
}

type Mutation {
  createSignup(input: SignupInput!): Signup!
  createIssuanceFromCsv(input: CreateIssuanceFromCsvInput!): Issuance!
  createIssuanceFromJson(input: CreateIssuanceFromJsonInput!): Issuance!
  appendEntriesToIssuance(input: AppendEntriesToIssuanceInput!): Issuance!
  createAttestation(input: AttestationInput!): Attestation!
  attestationSetPublished(input: AttestationSetPublishedInput!): Attestation!
  signingIterator(input: SigningIteratorInput!): UnsignedEntryPayload
  createKycRequest(input: KycRequestInput!): KycRequest!
  createEmailAddress(input: EmailAddressInput!): EmailAddress!
  createInvoiceLink(input: InvoiceLinkInput!): InvoiceLink!
  updateDownloadProofLink(input: DownloadProofLinkInput!): DownloadProofLink!
  deleteDownloadProofLink: DownloadProofLink!
  createEmailAddressVerification: EmailAddressVerification!
  updateIssuance(id: Int!): Issuance!
  updateTemplate(input: TemplateInput!): Template!
  updateWebCallbacksUrl(url: String): AccountState!
}

"Every attempt we made to deliver a WebCallback to your web_callbacks_url"
type WebCallbackAttempt {
  "Unique identifier for this Entry, across all Issuances."
  id: Int!
  "The id of the web callback this attempt was made for."
  webCallbackId: Int!
  "The date in which we made this attempt."
  attemptedAt: DateTime!
  "The url to which we made this attempt, which was your web_callbacks_url at the time."
  url: String!
  "The result of making this attempt. OK means everything went fine."
  resultCode: WebCallbackResultCode!
  "A text associated to the result code, showing your server's response body or details about network errors."
  resultText: String!
}

"The signup process in Constata can only be done through the website. It involves sending a special signed message in the request headers, but it also allows sending an initial email address to verify, which is represented by this input object."
input SignupInput {
  "email to be registered by the person, if any" email: String
  "boolean pointing out whether the email should be registered as private or could be public" keepPrivate: Boolean!
}

"A template input"
input TemplateInput {
  id: Int!
  action: String!
}

type Query {
  apiVersion: String!
  Entry(id: Int!): Entry!
  allEntries(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: EntryFilter): [Entry!]!
  _allEntriesMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: EntryFilter): ListMetadata!
  Issuance(id: Int!): Issuance!
  allIssuances(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: IssuanceFilter): [Issuance!]!
  _allIssuancesMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: IssuanceFilter): ListMetadata!
  Template(id: Int!): Template!
  allTemplates(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: TemplateFilter): [Template!]!
  _allTemplatesMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: TemplateFilter): ListMetadata!
  Pubkey(id: String!): Pubkey!
  allPubkeys(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: PubkeyFilter): [Pubkey!]!
  _allPubkeysMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: PubkeyFilter): ListMetadata!
  KycRequest(id: Int!): KycRequest!
  allKycRequests(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: KycRequestFilter): [KycRequest!]!
  _allKycRequestsMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: KycRequestFilter): ListMetadata!
  EmailAddress(id: Int!): EmailAddress!
  allEmailAddresses(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: EmailAddressFilter): [EmailAddress!]!
  _allEmailAddressesMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: EmailAddressFilter): ListMetadata!
  Attestation(id: Int!): Attestation!
  allAttestations(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: AttestationFilter): [Attestation!]!
  _allAttestationsMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: AttestationFilter): ListMetadata!
  WebCallback(id: Int!): WebCallback!
  allWebCallbacks(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: WebCallbackFilter): [WebCallback!]!
  _allWebCallbacksMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: WebCallbackFilter): ListMetadata!
  WebCallbackAttempt(id: Int!): WebCallbackAttempt!
  allWebCallbackAttempts(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: WebCallbackAttemptFilter): [WebCallbackAttempt!]!
  _allWebCallbackAttemptsMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: WebCallbackAttemptFilter): ListMetadata!
  PreviewEntry(id: Int!): PreviewEntry!
  UnsignedEntryPayload(id: Int!): UnsignedEntryPayload!
  EntryHtmlExport(id: Int!): EntryHtmlExport!
  AccountState(id: Int!): AccountState!
  EndorsementManifest(id: Int!): EndorsementManifest!
  EmailAddressVerification(id: Int!): EmailAddressVerification!
  InvoiceLink(id: String!): InvoiceLink!
  DownloadProofLink(id: String!): DownloadProofLink!
  AbridgedProofZip(id: String!): AbridgedProofZip!
  Proof(id: String!): Proof!
  IssuanceExport(id: Int!): IssuanceExport!
  AttestationHtmlExport(id: Int!): AttestationHtmlExport!
}

input PubkeyFilter {
  ids: [String!]
  idLike: String
}

"Contains a zip file with abridged proofs."
type AbridgedProofZip {
  "The numerical identifier of the entry."
  id: Int!
  "A suitable filename for this zip file, without the .zip extension."
  filename: String!
  "The base64 encoded contents of the zip"
  bytes: Bytes!
}

"An invoice generated when you chose a payment method and amount of tokens to buy, that has not been paid yet."
type Invoice {
  "Amount to pay, in EUR"
  amount: Int!
  "Tokens that you'll receive."
  tokens: Int!
  "Extra data about this invoice, if any."
  description: String!
  "Visit this url to continue your payment."
  url: String!
}

input TemplateFilter {
  ids: [Int!]
  idEq: Int
  nameLike: String
  archivedEq: Boolean
}

"An AttestationInput has all parameters required to create an Attestation on several of documents."
input AttestationInput {
  "An array of SignedPayloads containing all the documents to attest. See the tutorial for more info on signing payloads." documents: [SignedPayload!]!
  "An attestation allows appending documents up until a certain date. If you don't chose a date, no appending will be allowed." openUntil: DateTime
  "Markers is a text that can be used for searching this attestation later. Markers cannot be updated after creation." markers: String
  "A list of email addresses to notify when the documents are attested. Constata will email them an administrative access link to view, download or share the document certificate. You can pass an empty list if you want to omit Constata's emails, and manage distribution of the attestation in any other way." emailAdminAccessUrlTo: [String!]!
}

input WebCallbackAttemptFilter {
  ids: [Int!]
  idEq: Int
  webCallbackIdEq: Int
  resultCodeEq: WebCallbackResultCode
}

"An Entry represents a single certified Diploma, Proof of Attendance, or Badge, that is part of a larger Issuance. Each entry is certified separately, and has its own state. If you make several Issuances in parallel, you may run out of tokens, and some Entries will be certified while others will remain pending until you purchase the tokens."
type Entry {
  "Unique identifier for this Entry, across all Issuances."
  id: Int!
  "Id of the Issuance this entry belongs to."
  issuanceId: Int!
  "Name of the issuance this entry belongs to, for convenience."
  issuanceName: String!
  "This entries position within the larger Issuance. When the issuance is created from a CSV, this will be the row number."
  rowNumber: Int!
  "The state of this entry. Can be 'received': We got this row's data and will attempt to create a document such as a diploma, proof of attendance, or badge with the given details; 'created': The document was created correctly, and you should sign it; 'signed': You have signed this document, it is up to constata to certify it now; 'completed': The document has been timestamped and certified by Constata, and emailed to the recipient if required. 'failed': A problem ocurred that prevented further processing of this Entry, this could happen between 'received' and 'created' if the provided data is malformed. A failure in one single Entry will abort the whole Issuance, and nothing will be certified."
  state: String!
  "Date in which this entry was received by Constata"
  receivedAt: DateTime!
  "Parameters used to create this particular entry. If the issuance was created from a CSV, these will be the row's data."
  params: String!
  "Errors found when moving this entry from 'received' to 'created', if any."
  errors: String
  "ID of the document that this entry belongs to."
  documentId: String
  "ID of the story that this entry belongs to."
  storyId: Int
  "Boolean whether this entries admin link has been visited."
  adminVisited: Boolean!
  "When published, this is the visit count for the public page."
  publicVisitCount: Int!
  "Boolean that determines whether an email should be sent for this entry."
  hasEmailCallback: Boolean!
  "Date when the email was sent, if it has already been sent."
  emailCallbackSentAt: DateTime
  "The data payload for this entry."
  payload: String
  "The administrative access url for the direct recipient of this entry. They can use it to download, view or share the document."
  adminAccessUrl: String
}

"This object show us the information of a kyc request"
type KycRequest {
  "number identifying this kyc request"
  id: Int!
  "id of the person that requested this kyc"
  personId: Int!
  "id of the organization to which this person belongs"
  orgId: Int!
  "date in which this kyc request was created"
  createdAt: DateTime!
  "state of the kyc request, can be 'Pending' or 'Proccesed'"
  state: String!
  "Your first names"
  name: String
  "Your last names"
  lastName: String
  "Government or otherwise officially issued ID number"
  idNumber: String
  "Type of the officially issued id. Ej: DNI"
  idType: String
  "Date of birth"
  birthdate: DateTime
  "Country of birth"
  nationality: String
  "Country you currently live in."
  country: String
  "Your role, title or position in your company, if any."
  jobTitle: String
  "Name of the company"
  legalEntityName: String
  "Country where the company is based on, or where it has its HQ."
  legalEntityCountry: String
  "Company registration number in the required public registries, if any."
  legalEntityRegistration: String
  "Company tax identification number"
  legalEntityTaxId: String
}

input EmailAddressFilter {
  ids: [Int!]
  idEq: Int
  addressEq: String
  personIdEq: Int
}

"An issuance exported as a CSV file. All rows preserve the order of the original CSV file, or the order in which the entries were added through the API. New columns are added with details about each entry."
type IssuanceExport {
  "Unique identifier of the issuance."
  id: Int!
  "The CSV plain text of the issuance."
  csv: String!
}

input AttestationFilter {
  ids: [Int!]
  idEq: Int
  personIdEq: Int
  markersLike: String
}

"Input data object to register a new email address or change the visibility of a current one. "
input EmailAddressInput {
  "email to be registered by the person" address: String!
  "boolean pointing out whether the email should be registered as private or could be public" keepPrivate: Boolean!
}

input SignedPayload {
  payload: Bytes!
  signer: Addr!
  signature: MsgSig!
}

schema {
  query: Query
  mutation: Mutation
}
