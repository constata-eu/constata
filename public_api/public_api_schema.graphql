"Represents a batch generation and certification of diplomas, proofs of attendance, and badges from a template. Can be done through our Wizard from a CSV file, or incrementally using this API."
type Issuance {
  "Unique identifier for the issuance."
  id: Int!
  "Identifier of the template linked to this issuance."
  templateId: Int!
  "Name of the template linked to this issuance."
  templateName: String!
  "The kind of template, which can be 'Diploma', 'Attendance', or 'Invitation'."
  templateKind: TemplateKind!
  "The state of the issuance, which can be 'received': The recipients data has been received, and we're in the process of generating each recipients document; 'created': Individual entries have been generated from the selected template, using each recipient's data. At this point you can still add more recipients which will rewind the state to 'received'; 'signed': You have signed the entries, no further entries can be added. Documents will be certified and notified within 2 hours; 'completed': All entries have been certified and notified; 'failed': An error ocurred in the creation process, and the whole issuance has been aborted. Look at the errors field for more details."
  state: String!
  "The name of the issuance."
  name: String!
  "The date on which this issuance was created."
  createdAt: DateTime!
  "Errors that happened in the process of the issuance, if any. When an error occurs, the whole issuance is halted and no documents are certified."
  errors: String
  "Amount of tokens that the user must buy to certify this issuance."
  tokensNeeded: Int
  "Entries that belong to this issuance."
  entries: [Entry!]!
}

"This resource is used by Constata's frontend when you attempt to verify your email address following a link we send to your email."
type EmailAddressVerification {
  "Unique id of the email address that was verified"
  id: Int!
}

"This object has a file that proves the user identity"
input KycRequestEvidenceInput {
  "name of the file used as evidence for this kyc request" filename: String!
  "the file itself" payload: String!
}

"This object allows us to submit a kyc request to be considered by a constata admin"
input KycRequestInput {
  "email to be registered by the person" email: String!
  "boolean pointing out whether the email should be registered as private or could be public" keepPrivate: Boolean!
  "Your first names" name: String!
  "Your last names" lastName: String!
  "Government or otherwise officially issued ID number" idNumber: String
  "Type of the officially issued id. Ej: DNI" idType: String
  "Date of birth" birthdate: DateTime
  "Country of birth" nationality: String
  "Country you currently live in." country: String
  "Your role, title or position in your company, if any." jobTitle: String
  "Name of the company" legalEntityName: String
  "Country where the company is based on, or where it has its HQ." legalEntityCountry: String
  "Company registration number in the required public registries, if any." legalEntityRegistration: String
  "Company tax identification number" legalEntityTaxId: String
  "Your company LinkedIn page, if any." legalEntityLinkedinId: String
  "The files attached as proof for the details provided." evidence: [KycRequestEvidenceInput!]!
}

"The personal and company details you sent Constata for verification and to include in all your signed certificates. Keep in mind all fields are optional, this data is protected by data protection laws such as GDPR. https://api.constata.eu/terms_acceptance/show/#privacy_policies "
type KycEndorsementManifest {
  "Your first names"
  name: String
  "Your last names"
  lastName: String
  "Government or otherwise officially issued ID number"
  idNumber: String
  "Type of the officially issued id. Ej: DNI"
  idType: String
  "Date of birth"
  birthdate: DateTime
  "Country of birth"
  nationality: String
  "Country you currently live in."
  country: String
  "Your role, title or position in your company, if any."
  jobTitle: String
  "Name of the company"
  legalEntityName: String
  "Country where the company is based on, or where it has its HQ."
  legalEntityCountry: String
  "Company registration number in the required public registries, if any."
  legalEntityRegistration: String
  "Company tax identification number"
  legalEntityTaxId: String
  "Date of last update to this data."
  updatedAt: DateTime!
}

"The public key of a Person is used to sign certificates created through Issuances and Attestations. It's also used to authenticate to this API."
type Pubkey {
  "Unique ID of the pubkey, corresponds to a mainnet bitcoin address."
  id: String!
  personId: Int!
  orgId: Int!
}

input IssuanceFilter {
  ids: [Int!]
  idEq: Int
  templateIdEq: Int
  stateEq: String
  nameLike: String
}

"SigningIteratorInput Object"
input SigningIteratorInput {
  "ID of the issuance to which this entry belongs." issuanceId: Int!
  "Number that identifies this entry." entryId: Int
  "Signature applied to the referenced entry." signature: String
}

enum TemplateKind {
  DIPLOMA
  ATTENDANCE
  INVITATION
}

"This is your organization's account information and stats."
type AccountState {
  "Unique ID of your organization assigned by us."
  id: Int!
  "Tokens your organization needs to buy in order to certify all parked documents created through Issuances, Attestations or any other means."
  missing: Int!
  "You have this many tokens in your balance."
  tokenBalance: Int!
  "The special price you'll pay for each token when you buy them."
  pricePerToken: Int!
  "Constata will give you a monthly bonus of this many tokens, as a gift. When you submit an Issuance, Attestation or perform any other token consuming action, we'll credit these tokens as a gift instead of consuming your token balance."
  maxMonthlyGift: Int!
  "This number lowers every time Constata gives you a token from your max_monthly_gift"
  monthlyGiftRemainder: Int!
  "You have this many documents parked, that is, they won't be certified, until you take the requested action which may be buying the tokens needed to certify them, or accept changes to our terms and conditions."
  parkedCount: Int!
  "These are all the invoices you created for purchasing tokens and are still waiting for payment."
  invoices: [Invoice!]!
  "When this url is available, you should visit it on your browser to review and accept our terms and conditions. You can send it to whoever is in charge of accepting the terms in your organization."
  pendingTycUrl: String
  "Whenever you are missing tokens, you can visit this url in your browser and it will present you with payment options to buy the tokens you need. No login required, so you can send it to anyone in your organization in charge of payments."
  pendingInvoiceLinkUrl: String
}

"Your email account, as verified by Constata's email robot."
type EmailEndorsementManifest {
  address: String!
  "Whether you told us to use this email as part of your public endorsements or not."
  keepPrivate: Boolean!
}

"This object show an email address information"
type EmailAddress {
  "number identifying this email address"
  id: Int!
  "Id of the Person ownining this address"
  personId: Int!
  "The actual email address."
  address: String!
  "Date when the email was verified, if verified."
  verifiedAt: DateTime
  "Whether constata should also make this address part of the person's public signature information"
  keepPrivate: Boolean!
}

"This object show the id of the newly created person in reply to a signup. Remember signup can only be done through the website as some spam filtering checks are performed there."
type Signup {
  "number identifying the person who signed up"
  id: Int!
}

"Your telegram account as verified by Constata's telegram robot."
type TelegramEndorsementManifest {
  username: String
  firstName: String!
  lastName: String
}

input EntryFilter {
  ids: [Int!]
  idEq: Int
  issuanceIdEq: Int
  stateEq: String
  documentIdEq: String
  paramsLike: String
}

input KycRequestFilter {
  ids: [Int!]
  idEq: Int
  stateEq: String
}

"This object represents the link received by a user when requested to choose a payment method to buy tokens."
type InvoiceLink {
  "Number identifying an invoice link."
  id: Int!
  "Minimum suggested amount of tokens for the user to buy, taking into account missing tokens."
  minimumSuggested: Int!
  "Price per token that the user is going to pay."
  pricePerToken: Int!
  "URL of the invoice created with this invoice link, if any."
  invoiceUrl: String
}

type ListMetadata {
  count: Int!
}

"An Attestation over several documents"
type Attestation {
  id: Int!
  personId: Int!
  orgId: Int!
  markers: String!
  openUntil: DateTime
  state: String!
  parkingReason: String
  doneDocuments: Int!
  parkedDocuments: Int!
  processingDocuments: Int!
  totalDocuments: Int!
  tokensCost: Float!
  tokensPaid: Float!
  tokensOwed: Float!
  buyTokensUrl: String
  acceptTycUrl: String
  lastDocDate: DateTime
  emailAdminAccessUrlTo: [String!]!
  adminAccessUrl: String
  createdAt: DateTime!
}

"Represents an HTML preview of the contents of an entry."
type Preview {
  "The numerical identifier of the entry."
  id: Int!
  "The HTML formatted contents of the entry."
  html: String!
}

"This input object allows changing the public_certificate_is_active flag, to enable and disable sharing publicly."
input DownloadProofLinkInput {
  "Send 'publish' to enable, or 'unpublish' to disable. Any other value will be understood as 'unpublish'." action: String!
}

"This resource is used by Constata's admin front-end to show options for viewing, downolading or sharing a certificate on social networks. NOTICE: You should probably never use this resource yourself, use the Attestation and Issuance resources instead. If you insist on using it, keep in mind this endpoint does not authenticate using the 'Authentication' header, you should send an Auth-Token header with the special token generated for administrative access."
type DownloadProofLink {
  "Unique ID for this link."
  id: Int!
  "Expiration date, this admin link will not be valid after this date and time."
  validUntil: DateTime
  "A verifiable certificate may contain several documents. This many are pending to be certified."
  pendingDocCount: Int!
  "Creation date of the last document in this verifiable certificate."
  lastDocDate: DateTime
  "Public URL that displays this certificate, if sharing is active."
  publicCertificateUrl: String!
  "Whether this certificate's sharing is active. If so, the public_certificate_url can be shared on social media and viewed by anyone."
  publicCertificateIsActive: Boolean!
  "The text to display in the front-end for the 'share on social media' call to action."
  shareOnSocialNetworksCallToAction: String!
  documentFundedAt: DateTime
  entryTitle: String
  legalEntityLinkedinId: String
}

"A template that serves as a foundation for creating each Issuance Entry."
type Template {
  "An identifier for this template"
  id: Int!
  "The name of this template"
  name: String!
  "The type of issuance that can be created from this template. Possible values are 'Diploma', 'Attendance', or 'Badge'."
  kind: TemplateKind!
  "The date when this template was created"
  createdAt: DateTime!
  "The schema used to build the issuance entry"
  schema: String!
  "A personalized message that the user can add to the email sent to the student when the entry is certified"
  customMessage: String
  archived: Boolean!
}

"""
  Combined date and time (with time zone) in [RFC 3339][0] format.

  Represents a description of an exact instant on the time-line (such as the
  instant that a user account was created).

  [`DateTime` scalar][1] compliant.

  See also [`chrono::DateTime`][2] for details.

  [0]: https://datatracker.ietf.org/doc/html/rfc3339#section-5
  [1]: https://graphql-scalars.dev/docs/scalars/date-time
  [2]: https://docs.rs/chrono/latest/chrono/struct.DateTime.html
"""
scalar DateTime

"You can get an attestation as a verifiable HTML, embedding all documents and verifiable in any default browser."
type AttestationHtmlExport {
  id: Int!
  attestation: Attestation!
  verifiableHtml: String!
}

"A Person may have many endorsements from Constata, such as their identity, owning an email account, or being the manager of a website. This manifest gathers all those endorsements. You can only query your own manifest for now."
type EndorsementManifest {
  "You'll always get number 1."
  id: Int!
  "the final text to be used as the user endorsements, if any"
  text: String
  "websites registered by the user, if any"
  websites: [String!]!
  "data from the user's kyc endorsement, if any"
  kyc: KycEndorsementManifest
  "data from the user's telegram account, if any"
  telegram: TelegramEndorsementManifest
  "email registered by the user, if any"
  email: EmailEndorsementManifest
  "boolean pointing out whether the an email is going to be send to the student when created an issuance"
  canSendEmail: Boolean!
}

"This object is used by our frontend when a customer receives a link to create an invoice to purchase tokens."
input InvoiceLinkInput {
  "The payment method to use for this invoice ('Bitcoin' or 'Stripe')." paymentMethod: String!
  "The number of tokens to purchase with this invoice." tokens: Int!
}

"This object retrieves a certificate in verifiable HTML format authenticating with a special token, generated by our backend. This links can be sent to anyone and they will download the verifiable HTML. NOTICE If you need to download the verifiable HTML for any certificate authenticating to our API with your credentials, use the Issuances or Attestations endpoints instead."
type Proof {
  "Id of the certification "
  id: Int!
  "Certificate HTML contents as text"
  html: String!
}

type Mutation {
  createSignup(input: SignupInput!): Signup!
  createWizard(input: WizardInput!): Issuance!
  createAttestation(input: AttestationInput!): Attestation!
  signingIterator(input: SigningIteratorInput!): Entry
  createKycRequest(input: KycRequestInput!): KycRequest!
  createEmailAddress(input: EmailAddressInput!): EmailAddress!
  createInvoiceLink(input: InvoiceLinkInput!): InvoiceLink!
  updateDownloadProofLink(input: DownloadProofLinkInput!): DownloadProofLink!
  deleteDownloadProofLink: DownloadProofLink!
  createEmailAddressVerification: EmailAddressVerification!
  updateIssuance(id: Int!): Issuance!
  updateTemplate(input: TemplateInput!): Template!
}

"The signup process in Constata can only be done through the website. It involves sending a special signed message in the request headers, but it also allows sending an initial email address to verify, which is represented by this input object."
input SignupInput {
  "email to be registered by the person, if any" email: String
  "boolean pointing out whether the email should be registered as private or could be public" keepPrivate: Boolean!
}

"A template input"
input TemplateInput {
  id: Int!
  action: String!
}

type Query {
  apiVersion: String!
  Entry(id: Int!): Entry!
  allEntries(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: EntryFilter): [Entry!]!
  _allEntriesMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: EntryFilter): ListMetadata!
  Issuance(id: Int!): Issuance!
  allIssuances(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: IssuanceFilter): [Issuance!]!
  _allIssuancesMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: IssuanceFilter): ListMetadata!
  Template(id: Int!): Template!
  allTemplates(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: TemplateFilter): [Template!]!
  _allTemplatesMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: TemplateFilter): ListMetadata!
  Pubkey(id: String!): Pubkey!
  allPubkeys(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: PubkeyFilter): [Pubkey!]!
  _allPubkeysMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: PubkeyFilter): ListMetadata!
  KycRequest(id: Int!): KycRequest!
  allKycRequests(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: KycRequestFilter): [KycRequest!]!
  _allKycRequestsMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: KycRequestFilter): ListMetadata!
  EmailAddress(id: Int!): EmailAddress!
  allEmailAddresses(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: EmailAddressFilter): [EmailAddress!]!
  _allEmailAddressesMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: EmailAddressFilter): ListMetadata!
  Attestation(id: Int!): Attestation!
  allAttestations(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: AttestationFilter): [Attestation!]!
  _allAttestationsMeta(page: Int, perPage: Int, sortField: String, sortOrder: String, filter: AttestationFilter): ListMetadata!
  Preview(id: Int!): Preview!
  AccountState(id: Int!): AccountState!
  EndorsementManifest(id: Int!): EndorsementManifest!
  EmailAddressVerification(id: Int!): EmailAddressVerification!
  InvoiceLink(id: String!): InvoiceLink!
  DownloadProofLink(id: String!): DownloadProofLink!
  Proof(id: String!): Proof!
  IssuanceExport(id: Int!): IssuanceExport!
  AttestationHtmlExport(id: Int!): AttestationHtmlExport!
}

input PubkeyFilter {
  ids: [String!]
  idLike: String
}

"An invoice generated when you chose a payment method and amount of tokens to buy, that has not been paid yet."
type Invoice {
  "Amount to pay, in EUR"
  amount: Int!
  "Tokens that you'll receive."
  tokens: Int!
  "Extra data about this invoice, if any."
  description: String!
  "Visit this url to continue your payment."
  url: String!
}

input TemplateFilter {
  ids: [Int!]
  idEq: Int
  nameLike: String
  archivedEq: Boolean
}

"An AttestationInput has all parameters required to create an Attestation on several of documents."
input AttestationInput {
  "An array of SignedPayloads containing all the documents to attest. See the tutorial for more info on signing payloads." documents: [SignedPayload!]!
  "An attestation allows appending documents up until a certain date. If you don't chose a date, no appending will be allowed." openUntil: DateTime
  "Markers is a text that can be used for searching this attestation later. Markers cannot be updated after creation." markers: String
  "A list of email addresses to notify when the documents are attested. Constata will email them an administrative access link to view, download or share the document certificate. You can pass an empty list if you want to omit Constata's emails, and manage distribution of the attestation in any other way." emailAdminAccessUrlTo: [String!]!
}

"An Entry represents a single certified Diploma, Proof of Attendance, or Badge, that is part of a larger Issuance. Each entry is certified separately, and has its own state. If you make several Issuances in parallel, you may run out of tokens, and some Entries will be certified while others will remain pending until you purchase the tokens."
type Entry {
  "Unique identifier for this Entry, across all Issuances."
  id: Int!
  "Id of the Issuance this entry belongs to."
  issuanceId: Int!
  "Name of the issuance this entry belongs to, for convenience."
  issuanceName: String!
  "This entries position within the larger Issuance. When the issuance is created from a CSV, this will be the row number."
  rowNumber: Int!
  "The state of this entry. Can be 'received': We got this row's data and will attempt to create a document such as a diploma, proof of attendance, or badge with the given details; 'created': The document was created correctly, and you should sign it; 'signed': You have signed this document, it is up to constata to certify it now; 'completed': The document has been timestamped and certified by Constata, and emailed to the recipient if required. 'failed': A problem ocurred that prevented further processing of this Entry, this could happen between 'received' and 'created' if the provided data is malformed. A failure in one single Entry will abort the whole Issuance, and nothing will be certified."
  state: String!
  "Date in which this entry was created"
  createdAt: DateTime!
  "Parameters used to create this particular entry. If the issuance was created from a CSV, these will be the row's data."
  params: String!
  "Errors found when moving this entry from 'received' to 'created', if any."
  errors: String
  "ID of the document that this entry belongs to."
  documentId: String
  "ID of the story that this entry belongs to."
  storyId: Int
  "Boolean that determines whether an email should be sent for this entry."
  hasEmailCallback: Boolean!
  "Date when the email was sent, if it has already been sent."
  emailCallbackSentAt: DateTime
  "The data payload for this entry."
  payload: String
}

"This object show us the information of a kyc request"
type KycRequest {
  "number identifying this kyc request"
  id: Int!
  "id of the person that requested this kyc"
  personId: Int!
  "id of the organization to which this person belongs"
  orgId: Int!
  "date in which this kyc request was created"
  createdAt: DateTime!
  "state of the kyc request, can be 'Pending' or 'Proccesed'"
  state: String!
  "Your first names"
  name: String
  "Your last names"
  lastName: String
  "Government or otherwise officially issued ID number"
  idNumber: String
  "Type of the officially issued id. Ej: DNI"
  idType: String
  "Date of birth"
  birthdate: DateTime
  "Country of birth"
  nationality: String
  "Country you currently live in."
  country: String
  "Your role, title or position in your company, if any."
  jobTitle: String
  "Name of the company"
  legalEntityName: String
  "Country where the company is based on, or where it has its HQ."
  legalEntityCountry: String
  "Company registration number in the required public registries, if any."
  legalEntityRegistration: String
  "Company tax identification number"
  legalEntityTaxId: String
}

input EmailAddressFilter {
  ids: [Int!]
  idEq: Int
  addressEq: String
  personIdEq: Int
}

"An issuance exported as a CSV file. All rows preserve the order of the original CSV file, or the order in which the entries were added through the API. New columns are added with details about each entry."
type IssuanceExport {
  "Unique identifier of the issuance."
  id: Int!
  "The CSV plain text of the issuance."
  csv: String!
}

"Input object used to create an Issuance from scratch, either with a new template or an existing one."
input WizardInput {
  "The CSV file to be used for creating the entries." csv: String!
  "The name of the Issuance to be created." name: String!
  "The ID of an existing template to use, if any." templateId: Int
  "The kind of template to be created if no template is used." newKind: TemplateKind
  "The name of the new template to be created, if no template is used." newName: String
  "The text to be used as the logo for the new template, if no template is used." newLogoText: String
  "The image to be used as the logo for the new template, if no template is used." newLogoImage: String
}

"Input data object to register a new email address or change the visibility of a current one. "
input EmailAddressInput {
  "email to be registered by the person" address: String!
  "boolean pointing out whether the email should be registered as private or could be public" keepPrivate: Boolean!
}

input AttestationFilter {
  ids: [Int!]
  idEq: Int
  personIdEq: Int
  markersLike: String
}

"An AttestationInput has all parameters required to create an Attestation on several of documents."
input SignedPayload {
  payload: String!
  signer: String!
  signature: String!
}

schema {
  query: Query
  mutation: Mutation
}
